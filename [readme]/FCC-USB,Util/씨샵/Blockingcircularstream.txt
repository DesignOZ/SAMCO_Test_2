BlockingCircularStram.cs 
우선 Stream 클래스를 상속 받고 시작

-- 변수들 --

1. uBuffer = 사용할 버퍼
2. uWritePosition = 쓰기위한 자리?
3. uReadPosition = 읽기위한 자리?
4. uCapacity = 용량인듯한데
5. uBlockSignal = AutoResetEvent 형식으로 스레드 여러개가 하나가 끝날때까지 대기했다가 실행하는 방식으로 이벤트가 발생함. 그래서 블락이구나
6. uReadIsAborted = false -> 읽는거 중단한다?
7. uAccessLock -> 이거 그냥 상호배제용 객체

- AutoResetEvent 활용법
쓰레드 A가 AutoResetEvent 객체의 WaitOne() 메소드를 써서 대기하고 있다가, 다른 쓰레드 B에서 이 AutoResetEvent 객체의 Set() 메서드를 호출하면, 쓰레드 A는 대기 상태를 해제하고 계속 다음 문장을 실행할 수 있게 된다. 





-- 생성자 --
버퍼 용량을 인자로 받아서 uCapacity 에다가 저장하고
이 용량만큼 uBuffer 에 byte 단위로 배열 저장



-- Dispose --
중단을 처리하기 위한 메소드인듯
AbortRead() -> uReadIsAborted를 트루로 바꾸고 블락시그널.set() -> 대기중인 스레드 실행
한 뒤에 블락시그널.dispose() -> 스레드 자원을 반납.


-- Length --
get을 이용해서 이 Lengh를 호출하게되면 get 안의 내용이 튀어 나오는데
상호배제한 상태에서 쓸려는 위치가 읽으려는 위치보다 크거나 같으면 쓸려는 위치에다가 일읽으려는 위치를 뺀값을 반환하고
아니라면 전체용량에 쓸려는 위치값을 빼고 쓸려는 위치값을 더한것을 반납.
-> 핵심은 결국 버퍼의 현재 남은 공간을 표시하기 위함인듯함.


-- Read() --
버퍼와 변위, 카운터 값을 인자로 받아서
카운터 값이 버퍼용량보다 크면 예외발생시키고 (즉 카운터값이 읽을 데이터의 길인가)

uReadIsAborted를 false를 줘서 혹시나 전에 중단되서 true일 경우를 대비한 모양

- while(Lengh < count) - 
길이가 카운트값보다 작으면 시그널을 wait 시켜서 스레드 대기 시키고 읽는게 중단되었는지 확인하는데, 즉 읽으려는 총 길이보다 현재 길이가 작으면 버퍼를 읽을수있는 분량까지 확보후한다.

위 코드로 충분히 읽을 수있는 분량이 있다면
읽을 자리에 읽을 분량(count)를 더한 값이 전체 버퍼 용량보다 작은지 확인 후에
CopyBytes로 버퍼에 그 분량만큼 카피하고 읽을 자리에다가 count값을 더함

충분한 자리가 없다면
전체용량에 읽을 자리를 빼서 길이1로 저장하고 카운트값을 길이1로 빼서 길이2로 해서 나눈다. 그다음 하나씩 카피한다.
그리고 길이2를 현재까지 읽은 자리라고 설정한다.

이 과정까지 성공하면 카운트값을 반환한다.


--Write() --

써야할 량(count)이 용량보다 크다면 예외발생

아니라면

상호배제시켜서

현재 쓰는 위치와 써야할 분량 만큼 더한값이 전체 용량보다 작거나 같으면
정보를 카피하고 카운트만큼 현재 쓸 위치를 늘림.

아니라면
똑같이 분리해서 보냄 
그런데 길이2가 현재 읽을 위치보다 크다면 예외보냄(읽을 자료가 덧씌워짐)

그리고 대기중인 스레드를 실행한다.


-- CopyBytes() --







